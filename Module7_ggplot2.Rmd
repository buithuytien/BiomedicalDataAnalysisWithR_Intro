---
title: 'Module 7: Data visualization with ggplot2'
author: "ThuyTien Bui"
date: "17 April 2020"
output:
  slidy_presentation: default
  ioslides_presentation: default
footer: 'Biomedical data analysis with R: Intro series. Thuy Tien Bui'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## 7 layers of graphics
ggplot2 is based on the grammar of graphics, the idea that you can build every graph from the same few components: a data set, a set of geoms-visual marks that represent data points, and a coordinate system

Layer |	Description
------------- | -------------
Data	| The dataframe being plotted
Aesthetic | The scales onto which we map our data.
Geometry	| The visual elements (type of plot) used for our data.
Facet	| Plotting small multiples.
Statistics	| Representations of our data to aid understanding.
Coordinates	| The space on which the data will be plotted.
Themes	| All non-data ink.


## GGplot2 layers - Data

## The Iris dataset 
<Insert picture>

```{r data, echo = T, warning=FALSE, message=FALSE}
# install.packages(tidyverse)
library(tidyverse)
library(gridExtra)
data(iris)
head(iris)  
glimpse(iris)   # view the data frame
```


## GGplot2 layers - Aesthetics

Mapping Sepal length to X axis and Sepal Width to Y axis 
```{r aes mapping, echo = T, fig.align='center', fig.width=3, fig.height=3}
g <- ggplot(data = iris, mapping = aes (x = Sepal.Length, y = Sepal.Width))
g
```

No plot produced yet !

## GGplot2 layers - Geometry
```{r geom, echo = T, fig.align='center', fig.width=3, fig.height=3}
g <- ggplot(data = iris, mapping = aes (x = Sepal.Length, y = Sepal.Width)) +
      geom_jitter()
g
```

## GGplot2 layers - Facet
```{r facet, echo = T, fig.align='center', fig.width=6, fig.height=3}
g <- ggplot(data = iris, mapping = aes (x = Sepal.Length, y = Sepal.Width)) +
      geom_jitter(alpha = 0.6) + 
      facet_grid(. ~ Species)
g
```

## GGplot2 layers - Statistics
```{r stat, echo = T, fig.align='center', fig.width=6, fig.height=3}
g <- ggplot(data = iris, mapping = aes (x = Sepal.Length, y = Sepal.Width)) +
      geom_jitter(alpha = 0.6) + 
      facet_grid(. ~ Species) + 
      stat_smooth(method = "lm", se = F, col = "red")
g
```

## GGplot2 layers - Coordinates
```{r coord, echo = T, fig.align='center', fig.width=6, fig.height=3}
g <- ggplot(data = iris, mapping = aes (x = Sepal.Length, y = Sepal.Width)) +
      geom_jitter(alpha = 0.6) + 
      facet_grid(. ~ Species) + 
      stat_smooth(method = "lm", se = F, col = "red") +
      coord_equal()
g
```

## GGplot2 layers - Themes
```{r theme, echo = T, fig.align='center', fig.width=6, fig.height=3}
g <- ggplot(data = iris, mapping = aes (x = Sepal.Length, y = Sepal.Width)) +
      geom_jitter(alpha = 0.6) + 
      facet_grid(. ~ Species) + 
      stat_smooth(method = "lm", se = F, col = "red") +
      coord_equal() +
      theme_classic()
g
```

## 7 layers of graphics
Function |	Returns
------------- | -------------
**Data**	| The *dataframe* being plotted
**Aesthetic** | The scales onto which we map our data.
**Geometry**	| The visual elements (type of plot) used for our data.
Facet	| Plotting small multiples.
Statistics	| Representations of our data to aid understanding.
Coordinates	| The space on which the data will be plotted.
**Themes**	| All non-data ink.


## Visible aesthetics
## Mapping onto the X and Y axes

Scatter plot between sepal width and length. 
```{r, echo = T, fig.align='center', fig.width=3, fig.height=3}
g <- ggplot(data = iris, mapping = aes(x = Sepal.Length, 
                                       y = Sepal.Width))+
        geom_point()
g
```
They are discrete variables

## Mapping onto colors
```{r, echo = T}
unique(iris$Species)
```

**Species**, a dataframe column, is mapped onto color, a visible aesthetic.

```{r, echo = T, fig.align='center', fig.width=8, fig.height=3}
g1 <- ggplot(data = iris, mapping = aes(x = Sepal.Length, 
                                       y = Sepal.Width,
                                       color = Species ))+
        geom_point() +
        ggtitle("aes mapping inside ggplot")

g2 <- ggplot(data = iris)+
        geom_point(mapping = aes(x = Sepal.Length, 
                                 y = Sepal.Width,
                                 color = Species )) +
        ggtitle("aes mapping inside geom_point")

grid.arrange(g1, g2, nrow = 1)
```

Mapping inside geom_ is only necessary if:
- All layers should not inherit the same aesthetics
- Mixing different data sources


## Typical visible aesthetics

```{r, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- " 
| Aesthetic     | Description   |
|---------------|:-------------:|
| x             | X axis position
| y             | Y axis position
| fill          | Fill color
| color         | Color of points, outlines of other geoms
| size          | Area or radius of points, thickness of lines
| alpha         | Transparency
| linetype      | line dash pattern
| labels        | Text on a plot or axes
| shape         | Shape
"
cat(tabl) # output the table in a format good for HTML/PDF/docx conversion
```

## Using attributes - example
```{r, echo = T, fig.align='center', fig.width=3, fig.height=3}
g <- ggplot(data = iris, mapping = aes(x = Sepal.Length, 
                                       y = Sepal.Width  )) +
        geom_point(color = "red", shape = 17)
g
```
The **color** attribute is set to **"red"**
Attribute is set inside geom_*()

## Incorrect use:
```{r, echo = T, fig.align='center', fig.width=8, fig.height=3}
g1 <- g + ggtitle("Attribute set outside aes")
g2 <- ggplot(data = iris, mapping = aes(x = Sepal.Length, 
                                       y = Sepal.Width  )) +
        geom_point(aes(color = "red")) + 
        ggtitle("Incorrect! red is not a variable")

grid.arrange(g1, g2, nrow = 1)
```


## Aesthetics? Attributes?

Aesthetics are defined inside aes() in ggplot syntax and attributes are outside the aes().
```{r echo = T, fig.show='hide', fig.width=3, fig.height=3}
g <- ggplot(data = iris, mapping = aes(x = Sepal.Length, 
                                       y = Sepal.Width,
                                       color = Species)) +  # color mapped to Species variable
        geom_point(color = "red", shape = 17)   # color and shape set with constant value
```

We typically understand aesthetics as how something looks, color, size etc.
But in ggplot's world how things look is just an attribute.

Aesthetics do not refer how something looks, but to which **variable**, or dataframe **column** is mapped onto it.
Attributes refer to the property of the plot, and is set at a constant value (e.g ```color = "red"```, or  ```shape = 17``` )

## Appendix - scatter point shapes reference
![R scatter dot symbol](https://github.com/buithuytien/BiomedicalDataAnalysisWithR_Intro/blob/master/r_scatter_dot_symbol.png?raw=true)


## Modifying aesthetics
Aesthetic mapping (i.e., with aes()) only says that a variable should be mapped to an aesthetic. It doesn't say how that should happen. For example, when mapping a variable to shape with aes(shape = x) you don't say what shapes should be used. Similarly, aes(color = z) doesn't say what colors should be used. Describing what colors/shapes/sizes etc. to use is done by modifying the corresponding scale. 

#### In ggplot2 scales include:
- position
- color and fill
- size
- shape
- line type

## Positions - Adjustment for overlapping:
- identity
- dodge
- stack
- fill
- jitter
- jitterdodge
- nudge

## position = "identity" and position = "jitter"
Let's look at the dataframe again
```{r, echo = T, fig.align='center', fig.width=5, fig.height=3 }
head(iris)
```

Sepal.Length and Sepal.Width are discrete.
```position = "jitter" ``` adds noise to the scatter plot.

```{r, echo = T, fig.align='center', fig.width=8, fig.height=3 }
g1 <- ggplot(data = iris, mapping = aes(x = Sepal.Length, 
                                       y = Sepal.Width,
                                       color = Species ))+
        geom_point() +
        labs(title = "Default position = identity",
             subtitle = "150 points but overlapped")

g2 <- ggplot(data = iris, mapping = aes(x = Sepal.Length, 
                                       y = Sepal.Width,
                                       color = Species ))+
        geom_point(position = "jitter") +
        ggtitle("position = jitter")
grid.arrange(g1, g2, nrow=1)
```

## Control level of noise added by position_jitter()
```{r, echo = T, fig.align='center', fig.width=5, fig.height=3 }
posn_j <- position_jitter(0.1, seed = 136)   # set the seed for consistency between different runs
g <- ggplot(data = iris, mapping = aes(x = Sepal.Length, 
                                       y = Sepal.Width,
                                       color = Species ))+
        geom_point(position = posn_j)
g
```

## Scale functions
- Each of the aesthetic, which we map the data onto, has associated scale_ functions. We can access (and adjust) the scales via scale_* functions. For examples
- scale_x_*()
- scale_y_*()
- scale_color_*()
- scale_fill_*()
- scale_shape_*()
- scale_linetype_*()
- scale_size_*()


## scale_..._...() functions - examples
- Change axis names and legend title
- The third part of scale function must match the data we are using. In this example, the data on x-axis is continuous, and the Species (mapped to color) is discrete >> we have to use scale_x_continuous (instead of scale_x_discrete)
- There are many arguments for the scale function
- The first arguments are always the name of the scale. In this example, we name x-axis as "Sepal Length", and we name the legend title as "Sepcies"
- After that, most common are ```limit```,```breaks```, ```expand```, and ```label```
- scale_color_manual() defines properties of the color scale (i.e. axis). The first argument sets the legend title. ```Values``` is a named vector of colors to use.
```{r, echo = T, fig.align='center', fig.width=5, fig.height=3 }
palette <- c(setosa = "#377EB8", versicolor = "#E41A1C", virginica="#99FF99")
g <- ggplot(data = iris, mapping = aes(x = Sepal.Length, 
                                       y = Sepal.Width,
                                       color = Species )) +
        geom_point(position = "jitter") +
        scale_x_continuous(name="Sepal Length") +
        scale_color_manual(name="Species", values = palette)
g
```
[RBS color code](https://www.rapidtables.com/web/color/RGB_Color.html)

## The limit argument
Describe the scale range. In this example, x-axis is extended from 2 to 8
```{r, echo = T, fig.align='center', fig.width=5, fig.height=3 }
g <- ggplot(data = iris, mapping = aes(x = Sepal.Length, 
                                       y = Sepal.Width,
                                       color = Species )) +
        geom_point(position = "jitter") +
        scale_x_continuous("Sepal Length", limits = c(2, 8)) +
        scale_color_discrete("Species")
g
```

## The breaks argument
Controls the tick mark position
```{r, echo = T, fig.align='center', fig.width=5, fig.height=3 }
g <- ggplot(data = iris, mapping = aes(x = Sepal.Length, 
                                       y = Sepal.Width,
                                       color = Species )) +
        geom_point(position = "jitter") +
        scale_x_continuous("Sepal Length", limits = c(2, 8),
                           breaks = seq(2, 8, 3)) +
        scale_color_discrete("Species")
g
```

## The expand argument
2-element vector is passes into expand argument. They are the additive elements to the 2 axes, so that there is a small between the data and the axes.
```{r, echo = T, fig.align='center', fig.width=5, fig.height=3 }
g <- ggplot(data = iris, mapping = aes(x = Sepal.Length, 
                                       y = Sepal.Width,
                                       color = Species )) +
        geom_point(position = "jitter") +
        scale_x_continuous("Sepal Length", limits = c(2, 8),
                           breaks = seq(2, 8, 3), expand=c(0,0) ) +
        scale_color_discrete("Species")
g
```

## The labels argument
Adjust the category names. In this example, the legends are re-labelled.
```{r, echo = T, fig.align='center', fig.width=5, fig.height=3 }
g <- ggplot(data = iris, mapping = aes(x = Sepal.Length, 
                                       y = Sepal.Width,
                                       color = Species )) +
        geom_point(position = "jitter") +
        scale_x_continuous("Sepal Length", limits = c(2, 8),
                           breaks = seq(2, 8, 3), expand=c(0,0) ) +
        scale_color_discrete("Species",
                             labels = c("Setosa", "Versicolour", "Virginica") )
g
```

## Geom layer
48 geometries geom_*

abline    contour     dotplot       jitter      pointrange    ribbon      spoke
area      count       errorbar      label       polygon       rug         step
bar       crossbar    errorbarh     line        qq            segment     text
bin2d     curve       freqpoly      linerange   qq_line       sf          tile
blank     density     hex           map         quantile      sf_label    violin
boxplot   density2d   histogram     path        raster        sf_text     vline
col       density_2d  hline         point       rect          smooth

## Common plot types
Plot type         |	Possible geom_
-------------     | -------------
**Scatter plot**  | **points, jitter, abline, smooth, count**
Bar plot          | histogram, bar, col, errorbar
Line plot	        | line, path

## Scatter plots
Each geom can accept specific mappings.
For geom_point:
Essential mappings: x, y
Optional mapping: alpha, color, fill, shape, size, stroke


## Geom-specific aesthetic mappings
```{r, echo = T, results = 'hide', fig.align='center', fig.width=5, fig.height=3 }
# These result in the same plot!
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, col = Species)) +
  geom_point()
```

Control aesthetic mappings of each layer independently:
```{r, echo = T, fig.align='center', fig.width=5, fig.height=3 }
# These result in the same plot!
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) +
  geom_point(aes(col = Species))
```

## Inherited aes
```{r, echo = T, fig.align='center', fig.width=5, fig.height=3 }
head(iris, 3) # Raw data

iris %>%
  group_by(Species) %>%
  summarise_all(mean) -> iris.summary

iris.summary # Summary statistics
```

## Inherited aes
Both data and aes are inherited from ggplot() in geom_* layer
When data mapping is updated, the remaining aes mapping remains
```{r, echo = T, fig.align='center', fig.width=5, fig.height=3 }
g <- ggplot(iris, aes(x = Petal.Length, y = Petal.Width, col = Species)) +
      # Inherits both data and aes from ggplot()
      geom_point(position = "jitter") +
      # Different data, but inherited aes
      geom_point(data = iris.summary, shape = 15, size = 5, alpha = 0.6) # alpha = transparency
g
```


## adding geom_text() for annotation
- The geom_textlayer needs ```label``` aesthetic mapping
- Again, color is inherited from the ```ggplot``` function
```{r, echo = T, fig.align='center', fig.width=5, fig.height=3 }
iris.lab <- data.frame(Species = levels(iris$Species),
                       Petal.Length = iris.summary$Petal.Length,
                       Petal.Width  = c(0.7, 0.9, 1.3) )

g + geom_text(data = iris.lab, 
              mapping = aes(label = Species),
              show.legend = F)
```


## Bar plot
### Commmon plot types

Plot type    |	Possible geom_
-------------| -------------
Scatter plot | points, jitter, abline, smooth, count
**Bar plot** | **histogram, bar, col, errorbar**
Line plot	   | line, path

## Histogram - default values
Default number of bins is 30. We can pick better bin value by setting ```binwidth``` or ```bins```

```{r, echo = T, fig.align='center', fig.width=6, fig.height=3 }
g1 <- ggplot(iris, aes(x = Sepal.Width)) +
        geom_histogram() +
        ggtitle("Default number of bins (30)")

g2 <- ggplot(iris, aes(x = Sepal.Width)) +
        geom_histogram(binwidth = 0.1, center = 0.05) +
        ggtitle("binwidth = 0.1")

grid.arrange(g1, g2, nrow = 1)
```

## Multiple histograms - example with different species
Default position is "stack"
#### Problems?
```{r, echo = T, fig.align='center', fig.width=8, fig.height=3 }
g1 <- ggplot(iris, aes(x = Sepal.Width, fill = Species)) +
      geom_histogram(binwidth = 0.1, center = 0.05) + 
      ggtitle("Default position setting")

g2 <- ggplot(iris, aes(x = Sepal.Width, fill = Species)) +
      geom_histogram(binwidth = 0.1, center = 0.05, position = "stack") +
      ggtitle("position = stack")

grid.arrange(g1, g2, nrow = 1)
```
We cant say whether the histogram bars are stacked or overlapped onto each other


## Solution: position = "dodge" and position = "fill"
How about = "identity"?
```{r, echo = T, fig.align='center', fig.width=8, fig.height=3 }
g1 <- ggplot(iris, aes(x = Sepal.Width, fill = Species)) +
        geom_histogram(binwidth = 0.1, center = 0.05, position = "dodge") + 
        ggtitle("position = dodge")
g2 <- ggplot(iris, aes(x = Sepal.Width, fill = Species)) +
        geom_histogram(binwidth = 0.1, center = 0.05, position = "fill") + 
        ggtitle("position = fill")
grid.arrange(g1, g2, nrow = 1)
```

## To avoid: position = "identity"
```{r, echo = T, fig.align='center', fig.width=8, fig.height=3 }
g1 <- ggplot(iris, aes(x = Sepal.Width, fill = Species)) +
        geom_histogram(binwidth = 0.1, center = 0.05, position = "dodge") + 
        ggtitle("position = dodge")
g2 <- ggplot(iris, aes(x = Sepal.Width, fill = Species)) +
        geom_histogram(binwidth = 0.1, center = 0.05, position = "identity") + 
        ggtitle("position = identity")
grid.arrange(g1, g2, nrow = 1)
```


## Bar plot, with a categorical X-axis
- Use geom_bar or geom_col
- All positions from before are available
- Two types:
  - Absolute counts
  - Distribution

Geom         |	Stat        |  Action
-------------| -------------| -------------
geom_bar()   | "count"      | Counts the number of cases at each x position
geom_col()   | "identity"   | Plot actual values


## Barplot - absolute count
```{r, echo = T, fig.align='center', fig.width=3, fig.height=3 }
head(iris)

summary(iris)

ggplot(iris, aes(x=Species)) +
  geom_bar()
```

## Plotting distributions - adding decriptive statistics
```{r, echo = T, fig.align='center', fig.width=3, fig.height=3 }
# Calculate Descriptive Statistics:
sepal_width_summary <- iris %>%
                        select(Species, Sepal.Width) %>%
                        gather(key, value, -Species) %>%
                        group_by(Species) %>%
                        summarise(avg = mean(value),
                        stdev = sd(value))
```

## Adding error bar
 To be continued at stat_* layer
```{r, echo = T, fig.align='center', fig.width=3, fig.height=3 }
# Calculate Descriptive Statistics:
ggplot(sepal_width_summary, aes(x = Species, y = avg)) +
  geom_col() +
  geom_errorbar(aes(ymin = avg - stdev, ymax = avg + stdev),
  width = 0.1)
```


## Histogram is basically bar plot
```{r, echo = T, fig.align='center', fig.width=6, fig.height=3 }
g1 <- ggplot(iris, aes(x = Sepal.Width)) +
        geom_histogram(binwidth = 0.1) +
        ggtitle("geom_histogram")

g2 <- ggplot(iris, aes(x = Sepal.Width, y = ..count..)) + # ..count.. is a hidden variable
        geom_bar() +
        ggtitle("geom_bar")

grid.arrange(g1, g2, nrow = 1)
```


## Line plot (skipped)
### Commmon plot types

Plot type    |	Possible geom_
-------------| -------------
Scatter plot | points, jitter, abline, smooth, count
Bar plot     | histogram, bar, col, errorbar**
**Line plot**	   | **line, path**

## Examples with economics data set
unemployment and population statistics from the Federal Reserve Bank of St. Louis in the US. The data is contained in the ggplot2 package.
```{r, echo = T, fig.align='center', fig.width=3, fig.height=3 }
data(economics)
head(economics)
str(economics)
```
Note: The ```date``` column is formatted as ```Date```. This data type becomes handy when dealing with date, or date/time data. For converting data to ```Date``` formate, check out ```as.Date```


## Examples with economics data set
Line plot showing the fraction of total population that is unemployed
```{r, echo = T, fig.align='center', fig.width=3, fig.height=3 }
ggplot(economics, aes(x = date, y = unemploy/pop)) + # get fraction of total population that is unemployed
  geom_line()
```

## Periods of recession
In addition to the economics dataset from before, you'll also use the recess dataset for the periods of recession. The recess data frame contains 2 variables: the begin period of the recession and the end. It's already available in your workspace.
```{r, echo = T }
recess <- data.frame(begin = as.Date(c("1969-12-01","1973-11-01","1980-01-01","1981-07-01","1990-07-01")), 
                     end   = as.Date(c("1970-11-01","1975-03-01","1980-07-01","1982-11-01","1991-03-01")))


ggplot(economics, aes(x = date, y = unemploy/pop)) +
  geom_rect(data = recess,
            aes(xmin = begin, xmax = end, ymin = -Inf, ymax = +Inf),
            inherit.aes = FALSE, fill = "red", alpha = 0.2) +
  geom_line()
```

## The annotate() function

- The```annotate``` function adds geoms to a plot, but unlike typical a geom function, the properties of the geoms are not mapped from variables of a data frame, but are instead passed in as vectors. No aesthetic **mapping**
- This is useful for adding small annotations (such as text labels) or if you have your data in vectors, and for some reason don't want to put them in a data frame.
- The first argument is the type of geom to add, the other arguments correspond to the added geom

```
annotate(
  geom,
  
  # positioning aesthetics - you must specify at least one of these.
  x = NULL,   y = NULL,  
  xmin = NULL,  xmax = NULL,
  ymin = NULL,  ymax = NULL,
  xend = NULL,  yend = NULL,
  
  # Other arguments passed on to layer(). These are often aesthetics, like colour = "red"
  ...
)
```

## The annotate() function
- Remember this plot with ```geom_text()``` ? A line that separates versicolor and virginica on this plane was added. Support vector machine was used to "create" this line. The plot object is passed to variable ```g```
- We want to add an annotation to indicate this is an SVM hyperplane, and a curved arrow that points to the line.

```{r build SVM model between versicolor and virginica}
library(e1071)
set.seed(1)
df_train <- iris %>% subset(Species == c("versicolor", "virginica") ) %>%
                     select(c("Petal.Length", "Petal.Width", "Species"))

svm_model<- svm(Species ~ .,
                data = df_train,
                type = "C-classification" ,
                kernel = "linear" ,
                scale = FALSE)

# get slope and intercept for the linear hyperplane
w <- t(svm_model$coefs) %*% svm_model$SV   # calculate weight coefficients
slope_1 <- -w[1]/w[2]                      
intercept_1 <- svm_model$rho/w[2]
```

```{r, echo = F, fig.align='center', fig.width=5, fig.height=3 }
x_start = 5; y_start = 0.75
x_end = 5.5; y_end = intercept_1 + x_end * slope_1

g <- ggplot(iris, aes(x = Petal.Length, y = Petal.Width, col = Species)) +
      # Inherits both data and aes from ggplot()
      geom_point(position = "jitter") +
      geom_text(data = iris.lab, 
                mapping = aes(label = Species),
                show.legend = F)

g + geom_abline(slope = slope_1, intercept = intercept_1, linetype = 2)  # add a SVM hyper plane
```

## The annotate() function
- We use the annotate function to add a ```text``` geom, and a ```curve``` geom

```{r, echo = T, fig.align='center', fig.width=5, fig.height=3 }
x_start = 5; y_start = 0.75
x_end = 5.5; y_end = intercept_1 + x_end * slope_1
g + geom_abline(slope = slope_1, intercept = intercept_1, linetype = 2) + # add a SVM hyper plane
    annotate("text",
              x = x_start, y = y_start,
              label = "Support Vector\nMachine Hyperplane",
              vjust = 1, size = 3, color = "grey40") +
    annotate("curve", curvature = -0.1,
              x = x_start, y = y_start,
              xend = x_end, yend = y_end,
              arrow = arrow(length = unit(0.2, "cm"), type = "closed"),
              color = "grey40" )
```


## Statistics layler
Two categories of functions
- Called from within a geom
- Called independently
Can be accessed via stat_*

## Statistics with Geoms - histogram count

Another way to do histogram plot !
All methods count the time a specific sepal width value appears
```{r, echo = T, fig.align='center', fig.width=8, fig.height=3 }
g <- ggplot(iris, aes(x = Sepal.Width))
g1 <- g +
        geom_histogram(binwidth = 0.1) +
        ggtitle("geom_histogram")

g2 <- g +
        geom_bar(stat = "count") +
        ggtitle("geom_bar")

g3 <- g +
        stat_bin(binwidth = 0.1) +
        ggtitle("stat_bin")

grid.arrange(g1, g2, g3, nrow = 1)
```

## Statistics with geom - smoothing
stat_smooth can be accessed with geom_smooth
Standard error is showed as the grey ribbon behind each smoothing line. It is 5% confident interval by default

```{r, echo = T, fig.align='center', fig.width=8, fig.height=3 }
g <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, col = Species)) +
        geom_point()

g1 <- g + geom_smooth() + ggtitle("geom_smooth")

g2 <- g + stat_smooth() + ggtitle("stat_smooth")

grid.arrange(g1, g2, nrow = 1)
```
Note: By default, loess regression is used. It is a non-parametric methods where least squares regression is performed in localized subsets, and used when n < 1000. We can change smoothing method with the ```method``` argument

## More arguments with smoothing!
- ```se = FALSE``` turns off the ribbon (5% confident interval by default)
- *span* argument controls the degree of smoothing (size of sliding window in loess)
- *method* argument controls smoothing method

```{r, echo = T, fig.align='center', fig.width=8, fig.height=3, message=FALSE }
g <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, col = Species)) +
        geom_point()

g1 <- g + stat_smooth(se = FALSE,
                      span = 0.4)

g2 <- g + stat_smooth(se = FALSE,
                      method = "glm",
                      fullrange = TRUE )

grid.arrange(g1, g2, nrow = 1)
```

## Adding an smoothing line for all data
Use another stat_smooth layer, set a dummy variable "All" to color
```{r, echo = T, fig.align='center', fig.width=4, fig.height=3 }
g <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, col = Species)) +
        geom_point() +
        stat_smooth(method = "lm", se = F, aes(color="All")) +  # add a dummy variable mapping
        stat_smooth(method = "loess", se = FALSE)
g
```

## The geom_ / stat_ connection

```{r, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- " 
| stat_         | geom_         |
|---------------|:-------------:|
|stat_bin()     |geom_histogram() |
|stat_bin()     |geom_bar() |
|stat_bin()     |geom_freqpoly() |
|stat_smooth()  |geom_smooth() |
|stat_boxplot() |geom_boxplot() |
|stat_bindot()  |geom_dotplot() |
|stat_bin2d()   |geom_bin2d() |
|stat_binhex()  |geom_hex() |
|stat_contour() |geom_contour() |
|stat_quantile()|geom_quantile() |
|stat_sum()     |geom_count() |
"
cat(tabl) # output the table in a format good for HTML/PDF/docx conversion
```

## Statistics outside geom

## Basic plot
```{r, echo = T, fig.align='center', fig.width=3, fig.height=3 }
g <- ggplot(iris, aes(x = Species, y = Sepal.Length)) +
      geom_point(position = position_jitter(0.2))
g
```

## Calulating statistics with stat_summary
- fun.data
- fun.args
```{r, echo = T, fig.align='center', fig.width=3, fig.height=3 }
g <- ggplot(iris, aes(x = Species, y = Sepal.Length)) + 
      stat_summary(fun.y = mean, geom = "point") +
      stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), geom = "errorbar", width = 0.1)
g
```

## 95% confidence interval
```{r, echo = T, fig.align='center', fig.width=3, fig.height=3 }
g <- ggplot(iris, aes(x = Species, y = Sepal.Length)) + 
      stat_summary(fun.y = mean, geom = "point") +
      stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.1)
g
```

## Other stat_ functions
Function |	Returns
------------- | -------------
stat_summary()	| Summarise y values at distinct x values
stat_function() | Compute y values from a function of x values
stat_qq()	| Perform calculations for a quantile-quantile plot


## Example with stat_function
```{r, echo = T, fig.align='center', fig.width=3, fig.height=3 }
library(MASS)
head(mammals)

mam.new <- data.frame(body = log10(mammals$body))
ggplot(mam.new, aes(x = body)) +
  geom_histogram(aes( y = ..density..)) +
  geom_rug() +
  stat_function(fun = dnorm, colour = "red",
                arg = list(mean = mean(mam.new$body),
                sd = sd(mam.new$body)))
```

## QQ plot with stat_qq and stat_qq_line
By default, stat_qq_line fits with normal distribution.
```{r, echo = T, fig.align='center', fig.width=3, fig.height=3 }
mam.new <- data.frame(body = log10(mammals$body))
ggplot(mam.new, aes(sample = body)) +
  stat_qq(distribution = stats::qnorm) +
  stat_qq_line(distribution = stats::qnorm, color = "red", fullrange=T)
  # geom_abline(slope = 1, intercept = 0, col = "red")
```

## Coordinates layer
- plot dimensions: zoom-in, aspect ratio, polar coord (pie chart)

## Zooming in using scale_ and coord_
- What is the difference between the 2 zoomed-in plots?

```{r, echo = T, fig.align='center', fig.width=12, fig.height=3, message=FALSE }
g <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
  geom_point(alpha = 0.7) +
  geom_smooth()

g0 <- g + geom_vline(xintercept=4.5, linetype = 2) + 
          geom_vline(xintercept=5.5, linetype = 2) + 
          ggtitle("original plot")

g1 <- g + scale_x_continuous(limits = c(4.5, 5.5)) +
          ggtitle("Zoom in with scale_x_continuous()")

g2 <- g + coord_cartesian(xlim = c(4.5, 5.5)) +
          ggtitle("Zoom in with coord_()")

grid.arrange(g0, g1, g2, nrow=1)
```

## Zooming in using scale_ and coord_
- The scale functions change the underlying dataset before applying regression, which affects calculations made by computed geoms
- Coordinate functions make no changes to the dataset. In other words, regression is applied independently on the plot axis limit.
- Which one gives more accurate information?


```{r, echo = F, fig.align='center', fig.width=8, fig.height=3, message=FALSE }
g <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
  geom_point(alpha = 0.7) +
  geom_smooth()

g0 <- g + geom_vline(xintercept=4.5, linetype = 2) + 
          geom_vline(xintercept=5.5, linetype = 2) + 
          ggtitle("original plot")

g1 <- g + scale_x_continuous(limits = c(4.5, 5.5)) +
          labs(title = "scale_x_continuous()",
               subtitle = "Part of original data is filterred out")

g2 <- g + coord_cartesian(xlim = c(4.5, 5.5)) +
          labs(title = "Zoom in with coord_()",
               subtitle = "No change to dataset")

grid.arrange(g1, g2, nrow=1)
```

## Data transformation with coord_ and scale_
- We use the built-in msleep dataset for this example
- Body weight is highly skewed to the right side
- Log-transformation will give better visualization
```{r, echo = T, fig.align='center', fig.width=12, fig.height=3, message=FALSE }
data(msleep)
head(msleep)

ggplot(msleep, aes(bodywt, y = 1)) +
  geom_jitter() +
  scale_x_continuous(limits = c(0, 7000),
  breaks = seq(0, 7000, 1000))
```

## Data transformation with coord_ and scale_
- Apply a log-10 transformation to the plot on x-axis
- Giving 2 similar plots.
- HOWEVER, there are still fundamental differences between coord_ and scale_
  - scale transforms the data before plotting.
  - coord does not make any change to the dataset.
```{r, echo = T, fig.align='center', fig.width=12, fig.height=3, message=FALSE }
g <- ggplot(msleep, aes(bodywt, y = 1)) +
      geom_jitter() +
g1 <- g + scale_x_log10(limits = c(1e-03, 1e+04)) + 
          labs(title = "using scale_x_log10")
g2 <- g + coord_trans(x = "log10") +
          labs(title = "using coord_trans")

grid.arrange(g1, g2, nrow=1)
```

## Polar coordinate and pie chart
- Transforms stacked bar chart into pie chart
```{r, echo = T, fig.align='center', fig.width=8, fig.height=3, message=FALSE }
g <- ggplot(iris, aes(x=1, fill = Species)) +
      geom_bar()

g1 <- g + coord_polar(theta = "y") # transforms on y axis

grid.arrange(g, g1, nrow=1)
```

## The facet layer


```{r, echo = T, fig.align='center', fig.width=12, fig.height=3, message=FALSE }
# using tidyr package
iris2 <- iris %>%
  gather(key, Value, -Species) %>%
  separate(key, c("Part", "Measure"), "\\.")
head(iris2)
head(iris)

# ggplot
g1 <- ggplot(iris2[iris2$Species=="setosa", ], aes(x=Measure, y= Value, color = Part)) +
        geom_jitter() 
g2 <- ggplot(iris2[iris2$Species=="versicolor", ], aes(x=Measure, y= Value, color = Part)) +
        geom_jitter() 
g3 <- ggplot(iris2[iris2$Species=="virginica", ], aes(x=Measure, y= Value, color = Part)) +
        geom_jitter() 
grid.arrange(g1,g2,g3, nrow=1)

# ggplot
ggplot(iris2, aes(x = Measure, y = Value, color = Part)) +
  geom_jitter() +
  facet_grid(cols = vars(Species))
```

## Alternatively, using the facet layer
- Facets divide a plot into subplots based on the values of one or more discrete variables
- Given categorical variables A and B, the code pattern is
```
plot +
  facet_grid(rows = vars(A), cols = vars(B))
```
- Common legends for 3 subplots! The facet layer split the data into 3 subplots

```{r, echo = T, fig.align='center', fig.width=12, fig.height=3, message=FALSE }
# ggplot
ggplot(iris2, aes(x = Measure, y = Value, color = Part)) +
  geom_jitter() +
  facet_grid(cols = vars(Species))
```

## Adding labels and orders with facets (optional)
- Using msleep data
- "Vore" labels are not formal
```{r, echo = T, fig.align='center', fig.width=3, fig.height=3, message=FALSE }
data("msleep")
head(msleep2)
head(msleep2$vore, n = 20)
g <- ggplot(msleep2, aes(bodywt, brainwt)) +
      geom_point(alpha = 0.6)+
      scale_x_log10() + scale_y_log10() +
      coord_fixed()
```

## Adding labels and orders with facets
- Easy: Add labels in ggplot. However, we need to alter the dataset, or create a new copy of it
- Alternative: Relabel and rearrange factor variables in your dataframe
- fct_recode
```{r, echo = T, fig.align='center', fig.width=8, fig.height=3, message=FALSE }
msleep2$vore = fct_recode(msleep2$vore,
                          Carnivore = "carni",
                          Herbivore = "herbi",
                          Insectivore = "insecti",
                          Omnivore = "omni")

g <- ggplot(msleep2, aes(bodywt, brainwt)) +
      geom_point(alpha = 0.6)+
      scale_x_log10() + scale_y_log10() +
      coord_fixed() +
      facet_grid(cols = vars(vore))
g
```

## Theme layer
Non-data ink: visual elements that are not part of the data:

Visual element |	Modified using
-------------  | -------------
Text        	 | element_text()
Line           | element_line()
Rectangle      | element_rect()

## The text element
- Modified via element_text()
- A plot is composed of a combination of data, as well as non-data embellishments
- These are text element in the plot. Each element has its own unique name
- We can access all these text elements as arguments of the ```theme``` function
- Hiercarchical naming indicates inheritance rules

```
theme(
text,
  axis.title,
    axis.title.x,
      axis.title.x.top,
      axis.title.x.bottom,
  axis.title.y,
      axis.title.y.left,
      axis.title.y.right,
  title,
      legend.title,
    plot.title,
    plot.subtitle,
    plot.caption,
    plot.tag,
  axis.text,
    axis.text.x,
      axis.text.x.top,
      axis.text.x.bottom,
    axis.text.y,
      axis.text.y.left,
      axis.text.y.right,
  legend.text,
  strip.text,
      strip.text.x,
      strip.text.y)
```

```{r, echo = F, fig.align='center', fig.width=8, fig.height=3, message=FALSE }
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
geom_jitter(alpha = 0.6)
```


## Adjusting theme elements
- Call the appropriate argument inside the theme function and use the appropriate ```element_``` function (either ```element_text()```, ```element_text()```, ```element_text()```) to specify the value to change
- The below example moves legend box to the top (default position is on the right hand side)


```{r, echo = F, fig.align='center', fig.width=4, fig.height=4, message=FALSE }
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
  geom_jitter(alpha = 0.6) +
  theme(legend.position = "top")
```

## The line element
- Modified via element_line()
- The line elements include the tick marks, the axis line, and all grid line
- These are line elements in the ```theme``` function
- Hiercarchical naming indicates inheritance rules

```
theme(
line,
  axis.ticks,
    axis.ticks.x,
      axis.ticks.x.top,
      axis.ticks.x.bottom,
    axis.ticks.y,
      axis.ticks.y.left,
      axis.ticks.y.right,
  axis.line,
    axis.line.x,
      axis.line.x.top,
      axis.line.x.bottom,
    axis.line.y,
      axis.line.y.left,
      axis.line.y.right,
  panel.grid,
    panel.grid.major,
      panel.grid.major.x,
      panel.grid.major.y,
  panel.grid.minor,
      panel.grid.minor.x,
      panel.grid.minor.y)
```


## The line element
- Modified via element_rect()
- The rectangle elements include the borders and backgrounds
- These are line elements in the ```theme``` function
- Hiercarchical naming indicates inheritance rules

```
theme(
rect,
  legend.background,
  legend.key,
  legend.box.background,
  panel.background,
  panel.border,
  plot.background,
  strip.background,
    strip.background.x,
    strip.background.y)
```

## Inheritance
- For example, all text elements inherit from ```text```.
- If we change the text argument, all the downstream elements will be affected
```
theme(
text,
  axis.title,
    axis.title.x,
      axis.title.x.top,
      axis.title.x.bottom,
 ...)
```

## element_blank()
- Remove the item. The (removed) item will not be drawned at all
- In this example, we remove all text, rect and line items. The plot is left with just the data !

```{r, echo = T, fig.align='center', fig.width=3, fig.height=3, message=FALSE }
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
  geom_jitter(alpha = 0.6) +
  theme(line = element_blank(),
        rect = element_blank(),
        text = element_blank())
```

## Reusing theme by efining theme object
In this example, we change the font family, size, and title color. The theme is saved as an object


```{r, echo = T, fig.align='center', fig.width=8, fig.height=3, message=FALSE }
theme_exp <- theme(text = element_text(family = "serif", size = 14),
              rect = element_blank(),
              panel.grid = element_blank(),
              title = element_text(color = "#8b0000"),
              axis.line = element_line(color = "black"))

g <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
      geom_jitter(alpha = 0.6) +
      scale_x_continuous("Sepal Length (cm)", limits = c(4,8), expand = c(0,0)) +
      scale_y_continuous("Sepal Width (cm)", limits = c(1.5,5), expand = c(0,0)) +
      scale_color_brewer("Species", palette = "Dark2", labels = c("Setosa", "Versicolor", "Virginica"))

grid.arrange(g+ggtitle("Default theme"), g + ggtitle("g + theme_exp") + theme_exp, nrow=1)
```


## Reuse theme_exp in another plot
```{r, echo = T, fig.align='center', fig.width=3, fig.height=3, message=FALSE }
m <- ggplot(iris, aes(x = Sepal.Width)) +
      geom_histogram(binwidth = 0.1,
      center = 0.05)
m + theme_exp
```

## Resuse themes with built-in themes
- There are numerous built-in themes in ggplot2 package and the other packages (such as ggtheme)
- Use the ```theme_*()``` functions to access the built-in themes in ggplot2 
- We can still modify any specific element.

```{r, echo = T, fig.align='center', fig.width=8, fig.height=3, message=FALSE }
g1 <- g + theme_classic()
g2 <- g + theme_classic() + theme(text = element_text(family = "serif"))

grid.arrange(g1+ggtitle("theme_classic()"), g2 + ggtitle("modified theme_classic()") + theme_exp, nrow=1)
```


## Manage multiple plotting objects
- We already see example with grid.arrange function in grid.Extra package
- Here is a more structured introduction

## A list of ggplot2 objects is passed to grid.arrange
```{r, echo = T, fig.align='center', fig.width=5, fig.height=3, message=FALSE }
plotIris <- function(species){
  df <- iris %>% subset(Species == species)
  g <- ggplot(iris, aes(x = Petal.Length, y = Petal.Width, col = Species)) +
        geom_point(position = "jitter") + 
        scale_x_continuous("Petal Length") + 
        scale_y_continuous("Petal Width") +
        ggtitle(species) + 
        theme_classic()
  return(g)
}

# create a list of ggplot2 objects
my_plots <- lapply(levels(iris$Species), plotIris)

length(my_plots)

my_plots[[1]]
```

We can do the same thing by using facet_ layer, but this is for illustration purpose.

## Combine plots with grid.arrange
```{r, echo = T, fig.align='center', fig.width=12, fig.height=3, message=FALSE }
library(gridExtra)
grid.arrange(my_plots[[1]], my_plots[[2]], my_plots[[3]], 
             nrow=1, ncol=3 )
```

## Combine plots, a more efficient way with ```do.call```
- ```do.call``` constructs and executes a function call from a name or a function and a list of arguments to be passed to it.
- The first argument to pass to ```do.call``` is the name of the function we want to apply. The arguments to the function is passed to a vector
- We can pass the whole list (of ggplot2 object) at once in the the ```args`` argument

```{r, echo = T, fig.align='center', fig.width=12, fig.height=3, message=FALSE }
library(gridExtra)
do.call(what = grid.arrange, 
        args = c(my_plots, nrow=1, ncol=3))
```

## Combine plots with ggpubr
- An very (simple and user-friendly) alternative to ggplot2 is ggpubr
- In this example, we only explore the ```ggarrange``` function to combine multiple plots
- One advantage of ```ggpubr::ggarrange``` is the panel label, and the option to set common legend. The ```gridExtra::grid.arrange``` can do this, but more complicated.
- We can also pass the function and arguments to ```do.call```
```{r, echo = T, fig.align='center', fig.width=8, fig.height=3, message=FALSE }
p <- ggpubr::ggarrange(my_plots[[1]], my_plots[[2]], my_plots[[3]], 
                        nrow=1, ncol=3,
                        common.legend = TRUE, legend = "bottom",
                        labels=c("A","B","C"))
p
```

## Saving your plot (in high-resolution image)
```
ggsave(
  filename,
  plot = last_plot(),
  device = NULL,
  path = NULL,
  scale = 1,
  width = NA,
  height = NA,
  units = c("in", "cm", "mm"),
  dpi = 300,
  limitsize = TRUE,
  ...
)
```

## Saving your plot (in high-resolution image)
```{r, echo = T, fig.align='center', fig.width=8, fig.height=3, message=FALSE }
p
# save to file
ggsave(filename = "iris_combine.png", 
       plot=p, 
       dpi=800, 
       width=9, height=3, units=("in"))
```


## Special plots - examples (optional)
- Density and 2D density
- Correlation matrix
- Network plot
- Map
- Dimension reduction: PCA, MDS, t-SNE, etc...



## R Markdown

This is an R Markdown presentation. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document.

## Slide with Bullets

- Bullet 1
- Bullet 2
- Bullet 3

## Slide with R Output

```{r cars, echo = TRUE}
summary(cars)
```

## Slide with Plot

```{r pressure}
plot(pressure)
```

